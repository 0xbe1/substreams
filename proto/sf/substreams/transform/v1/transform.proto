syntax = "proto3";

package sf.substreams.transform.v1;

option go_package = "github.com/streamingfast/substreams/pb/sf/substreams/transform/v1;pbtransform";

message Transform {
  string output_module = 1; //todo: stream should always be a module of the map, right?
  Manifest manifest = 2;
}

message Manifest {
  string spec_version = 1;
  string description = 2;
  repeated Module modules = 3;
  repeated bytes modules_code = 4;
}

message Module {
  string name = 1;
  oneof kind {
    KindMap kind_map = 2;
    KindStore kind_store = 3;
  };

  oneof code {
    WasmCode wasm_code = 4;
    NativeCode native_code = 5;
  }

  repeated Input inputs = 6;
  Output output  = 7;
  uint64 start_block = 8;
}

message WasmCode {
  string type = 4;
  uint32 index = 5;
  string entrypoint = 6;
}

message NativeCode {
  string entrypoint = 5;
}

message KindMap {
  string output_type = 1;
}

message KindStore {
  // The UpdatePolicy determines what is possible to do with the store
  // (the operations permitted no it, like set(), or sum(), etc..)  in
  // order to ensure parallel operations are deterministic and
  // possible.
  //
  // Say a store cumulates keys from block 0 to 1M, and a second store
  // cumulates keys from block 1M to 2M. When we want to use this
  // store as a dependency for a downstream module, we will merge the
  // two stores according to this policy.
  enum UpdatePolicy {
    UPDATE_POLICY_UNSET = 0;
    // Provides a store where you can `set()` keys, and the latest key wins
    UPDATE_POLICY_REPLACE = 1;
    // Provides a store where youc an `set_if_not_exists()` keys, and the first key wins
    UPDATE_POLICY_IGNORE = 2;
    // Provides a store where you can `sum_*()` keys, where two stores merge by summing its values.
    UPDATE_POLICY_SUM = 3;
    // Provides a store where you can `min_*()` keys, where two stores merge by leaving the minimum value.
    UPDATE_POLICY_MIN = 4;
    // Provides a store where you can `max_*()` keys, where two stores merge by leaving the maximum value.
    UPDATE_POLICY_MAX = 5;
  }
  UpdatePolicy update_policy = 1;
  string value_type = 2;
}


message  Input {
  oneof input{
    InputSource source = 1;
    InputMap map = 2;
    InputStore store = 3;
  }
}
message  Output {
  string type = 1;
}

message InputSource {
  string type = 1; // ex: "sf.ethereum.type.v1.Block"
}
message InputMap {
  string module_name = 1; // ex: "block_to_pairs"
}
message InputStore {
  string module_name = 1;
  enum Mode {
    UNSET = 0;
    GET = 1;
    DELTAS = 2;
  }
  Mode mode = 2;
}


message DatabaseChanges {
  repeated TableChange tableChanges = 1;
}

//table.1
// create f.1 o.10 n.99
// update f.1 o.99 n.200
// update f.2 o.abc n.xyz
// update f.1 o.200 n.400

//table.1
// create f.1 o.10 n.400 f.2 o.abc n.xyz


//table.1
// update f.1 o.10 n.99
// update f.1 o.99 n.200
// update f.2 o.abc n.xyz
// update f.1 o.200 n.400

//table.1
// update f.1 o.10 n.400 f.2 o.abc n.xyz

message TableChange {
  string table = 1;
  string pk = 2;
  uint64 block_num = 3;
  uint64 ordinal = 4;
  enum Operation {
    CREATE = 0;
    UPDATE = 1;
    DELETE = 2;
  }
  Operation operation = 5;
  repeated Field fields = 6;
}

message Field {
  string name = 1;
  string new_value = 2;
  string old_value = 3;
}
